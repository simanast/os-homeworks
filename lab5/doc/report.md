## Лабораторная работа №5.
### Файлы и файловые системы.

1.  Используя creat(), write(), fflush(), close(), gettimeofday(), разработать программу, которая
    открывает файл, записывает туда 300 KB, очищает все записи, закрывает и удаляет файл,
    а также измеряет и выводит время, затраченное на каждое действие.

2.  Разработать программу, которая замеряет время для 300,000 однобайтовых записей с использованием  
    1) напрямую POSIX: creat(), write(), close().  
    2) с использованием библиотеки stdio (напр., fopen(), fwrite(), and fclose()).  
    Сравнить и объяснить результаты.  
    
    ```
    time elapsed for POSIX function		: 0.611629 sec
    time elapsed for <stdio.h> function	: 0.006805 sec
    ```
    
    Использование POSIX функций записывает медленнее, т.к. при каждой записи напрямую обращается к памяти, а бибилиотечные функции используют буфер для сокращения количества этих дорогостоящих операций.  
    
3.  Разработать собственную версию (mytail) команды tail.  
    Формат: mytail -n file
    Она читает блок из конца файла, просматривает его с конца до заданного количества строк n и печатает эти строки
    в соответствующем порядке.
    Использовать: stat(), lseek(), open(), read(), close(), ...  
    
    Эта функция возвращает информацию об указанном файле. Для этого не требуется иметь права доступа к файлу, хотя потребуются права поиска во всех каталогах, указанных в полном имени файла.
    stat возвращает информацию о файле file_name и заполняет буфер buf.

        struct stat {
            dev_t         st_dev;      /* устройство */
            ino_t         st_ino;      /* inode */
            mode_t        st_mode;     /* режим доступа */
            nlink_t       st_nlink;    /* количество жестких ссылок */
            uid_t         st_uid;      /* идентификатор пользователя-владельца */
            gid_t         st_gid;      /* идентификатор группы-владельца */
            dev_t         st_rdev;     /* тип устройства */
                                       /* (если это устройство) */
            off_t         st_size;     /* общий размер в байтах */
            blksize_t     st_blksize;  /* размер блока ввода-вывода */
                                       /* в файловой системе */
            blkcnt_t      st_blocks;   /* количество выделенных блоков */
            time_t        st_atime;    /* время последнего доступа */
            time_t        st_mtime;    /* время последней модификации */
            time_t        st_ctime;    /* время последнего изменения */
        };
    
    ```off_t lseek(int fildes, off_t offset, int whence);```  
    
    Функция lseek устанавливает смещение для файлового дескриптора 
    fildes в значение аргумента offset в соответствии с директивой 
    whence которая может принимать одно из следующих значений:
    
    SEEK_SET
        Смещение устанавливается в offset байт (от начала файла -- прим. пер.). 
    SEEK_CUR
        Смещение устанавливается как текущее смещение плюс offset 
        байт. 
    SEEK_END
        Смещение устанавливается как размер файла плюс offset байт. 
    
    Функция lseek позволяет задавать смещения, которые будут 
    находиться за существующим концом файла (но это не изменяет 
    размер файла).  
    
4.  Разработать собственную версию (mystat) команды stat, 
    которая просто осуществляет системный вызов stat(), выводит
    размер, число задействованных блоков, число жестких 
    ссылок и т. д. Отследить, как меняется число ссылок при их 
    добавлении/удалении.
    
    Имя файла, ссылающееся на его индексный дескриптор, 
    называется жесткой ссылкой. Механизм жестких ссылок – это основной 
    способ обращаться к файлу в Unix-подобных операционных системах 
    вся информация о файле привязана не к его имени, а так называемому 
    числовому индексному дескриптору. У каждого файла есть свой 
    уникальный индексный дескриптор, 
    к которому привязаны сведения об этом файле: в каких блоках 
    диска хранится его содержимое, размер, время создания, 
    модификации и др.
    
    Жесткая ссылка работает как зеркальная копия оригинального файла. Эти ссылки используют одни и те же индексные дескрипторы (иноды). Изменения в одном из файлов, связанных жесткой ссылкой, отразятся в другом. При удалении жесткой ссылки с другим файлом ничего не произойдет. Жесткие ссылки не могут связывать различные файловые системы. Синтаксис для создания жесткой ссылки следующий
    
        ln <источник> <ссылка>

5.  Разработать собственную версию (myls) команды ls, которая выводит список файлов в заданной директории. С ключом -l она выводит информацию о каждом файле, включая собственника, группу, разрешения и т.д., получаемые из системного вызова stat(). Формат: myls -l directory (или текущую директорию, если параметр не задан) Использовать: stat(), opendir(), readdir(), getcwd(), ...
    ```
    int closedir(DIR *ptr)
    DIR *opendir(char *dirname)
    struct dirent *readdir(DIR *ptr)
    ```
    Функция opendir() открывает поток каталога и возвращает указатель на структуру типа DIR, которая содержит информацию о каталоге. 
    Функция readdir() возвращает название следующего файла в каталоге. 
    Иными словами, функция readdir() читает оглавление каталога по одному файлу за раз. Параметр ptr 
    должен указывать на поток каталога, открытый с помощью opendir().
    
    ```char *getcwd(char *dir, int len)```  
    Функция getcwd() копирует полный путь (максимум len символов) текущего рабочего каталога диска в строку, на которую указывает параметр dir. Если полный путь длиннее, чем len символов, то возникает ошибка. Функция getcwd() возвращает указатель на dir.
    
6.  Разработать программу, которая выводит имена каждого файла и директории, начиная с заданной точки в дереве каталогов.  
        
    - Без аргументов: сначала текущая директория и ее содержимое, затем поддиректории и т.д. (пока не закончится дерево,
    root в качестве CWD).  
    - С одним аргументом (который есть имя директории): все поддерево, начиная с заданной директории.  
    - Если указать ключ -size, программа выведет размер файлов в байтах  
        

  
