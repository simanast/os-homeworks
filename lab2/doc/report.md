## Лабораторная работа № 2
### Управление процессами
#### Цель - получить представление о использовании основных APIs операционной системы. 

+ Ознакомиться с текстом и программами
    Текст: Operating Systems: Three Easy Pieces (available at http://www.ostep.org)->5. Interlude: Process API
    Программы: https://github.com/remzi-arpacidusseau/ostep-code/tree/master/cpu-api
    Upon successful completion, fork() returns 0 to the child process and returns the process ID of the child process to the parent process. Otherwise, -1 is returned to the parent process, no child process is created, and errno is set to indicate the error.

+ В основной программе переменной x присвоить значение 100, а затем вызвать fork(). Каково значение x в порождённом процессе? Что происходит, когда основной и порожденный процессы меняют значение x?  
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    int main() {
        int x = 100;
        int rc = fork();
        if (rc < 0) {
            // fork failed, exit
            fprintf(stderr, "fork failed\n");
            exit(1);
        }
        if (rc == 0) { // child
            printf("child: x = %d\n", x);
            x = 0;
            printf("child: new x = %d\n", x);
            exit(0);
        } else { // parent
            printf("parent: x = %d\n", x);
            x = 5;
            printf("parent: new x = %d\n", x);
        }
        return 0;
    }
    ```  
    При вызове fork() создаётся новый процесс, который будет являться точной 
    копией родительского процесса. Для потомка создаётся отдельное адресное 
    пространство, поэтому изменение переменной x в одном процессе не влияет на 
    ту же переменную из другого процесса.  
    Вывод: 
    ```
    parent: x = 100
    parent: new x = 5
    child: x = 100
    child: new x = 0
    ```  
    + Порожденный процесс, созданный с помощью fork(), должен напечатать “hello”; основной - “goodbye”. Нужно обеспечить, чтобы порожденный процесс печатал первым без использования wait() в основном.  
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <signal.h>
    
    void print_goodbye(int signo) {
        printf("goodbye\n");
        exit(0);
    }
    
    int main() {
        int parent_id = getpid();
        int rc = fork();
        if (rc < 0) {
            // fork failed, exit
            fprintf(stderr, "fork failed\n");
            exit(1);
        }
        if (rc > 0) { // parent
            signal(SIGCHLD, print_goodbye);
            sleep(1);
        }
        if (rc == 0) { // child
            printf("hello\n");
            kill(parent_id, SIGCHLD);
            exit(0);
        }
    }
    ```
    
    ```c
    int kill(pid_t pid, int sig);
    sighandler_t signal(int signum, sighandler_t handler);
    ```  
    Используем функцию kill(), которая отправляет процессу с идектификатором pid сигнал sig, чтобы отправить основному процессу после вывода строки сигнал. В основном процессе используем функцию signal(), которая устанавливает обработчиком сигнала с номером signum функцию handler.  

+  Сначала вызывается fork(), а затем какой-либо вариант  exec() (execl(), execle(), execlp(), execv(), execvp(), и execvpe()) для вызова  /bin/ls. 
Для чего предусмотрено столько много вариантов exec()?  
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/wait.h>
    
    int main() {
        int x = 100;
        char *args[2];
        args[0] = "/bin/ls";
        args[1] = NULL;
        int rc = fork();
        if (rc < 0) {
            // fork failed, exit
            fprintf(stderr, "fork failed\n");
            exit(1);
        }
        if (rc == 0) { // child
            execv(args[0], args);
            exit(0);
        } else { // parent
            int rc_wait = wait(NULL);
        }
        return 0;
    }
    ```
    
    Семейство функций exec():
    ```c
    int execl(char *name, char *arg0, ... /*NULL*/);
    int execv(char *name, char *argv[]);
    int execle(char *name, char *arg0, ... /*,NULL, char *envp[]*/);
    int execve(char *name, char *arv[], char *envp[]);
    int execlp(char *name, char *arg0, ... /*NULL*/);
    int execvp(char *name, char *argv[]);
    ```
    Вызов exec происходит таким образом, что переданная в качестве аргумента 
    программа загружается в память вместо старой, которая вызвала exec. 
    Старой программе больше не доступны сегменты памяти, которые перезаписаны новой программой.
    Суффиксы l, v, p, e в именах функций определяют формат и объем аргументов, 
    а также каталоги, в которых нужно искать загружаемую программу:
    
        l (список). Аргументы командной строки передаются в форме списка arg0, arg1.... argn, NULL. Эту форму используют, если количество аргументов известно;
        v (vector). Аргументы командной строки передаются в форме вектора argv[]. Отдельные аргументы адресуются через argv [0], argv [1]... argv [n]. Последний аргумент (argv [n]) должен быть указателем NULL;
        p (path). Обозначенный по имени файл ищется не только в текущем каталоге, но и в каталогах, определенных переменной среды PATH;
        e (среда). Функция ожидает список переменных среды в виде вектора (envp []) и не использует текущей среды.
    
    Здесь используем execv(const char *path, char *const argv[]).  
+ В основной программе использовать wait() для того, чтобы дождаться завершения порожденного процесса? Что возвращает wait()? Что произойдет, если использовать wait() в порожденном процессе? Использовать waitpid() вместо of wait(). Когда использование waitpid() целесообразно?  
    ```pid_t waitpid(pid_t pid, int *wstatus, int options);```  
    
    Значение pid:
    
           < -1   означает, что нужно ждать  любого  дочернего  процесса,  
                  чей  идентификатор  группы
                  процессов равен абсолютному значению pid.
    
           -1     ожидать любого дочернего процесса; функция wait ведет себя точно так же.
    
           0      означает  ожидать  любого  дочернего  процесса,  чей идентификатор 
                  группы процессов
                  равен таковому у текущего процесса.
    
           > 0    ожидать дочернего процесса, идентификатор равен pid.
    
    Значение options создается путем битовой операции ИЛИ над следующими константами:
    
           WNOHANG
                  означает вернуть управление немедленно, если ни один дочерний процесс  не  завершил
                  выполнение.
    
           WUNTRACED
                  означает  возвращать  управление также для остановленных дочерних процессов, о чьем
                  статусе еще не было сообщено.
    
    Если status не равен NULL, то функции wait и waitpid  сохраняют  информацию  о  статусе  в переменной, на которую указывает status.
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
    
           Идентификатор дочернего процесса, который завершил выполнение,  -1  в  случае  ошибки  или
           нуль,  если  использовался WNOHANG, но ни один дочерний процесс еще не завершил выполнение
           (в этом случае errno устанавливается должным образом).
    
    Использование waitpid():  
    Если есть несколько дочерних процессов, эта функция ожидает завершения указанного с помощью pid дочернего процесса.   
 
+ Программа порождает процесс и в нем закрывает стандартный вывод (STDOUT FILENO). Что произойдет, если осуществить вызов printf() для того, чтобы что-то вывести в основном и дочернем процессах?
    
    Так как printf() по умолчанию выводит в стандартный вывод, в дочернем процессе 
    нельзя будет вывести строку, но можно будет в родительском.
    
    + Разработать программу, которая создает два порожденных процесса и соединяет стандартный вывод одного со стандартным вводом другого с использованием pipe().  
    ```int pipe(int pipefd[2]);```  
    
    pipe() создаёт однонаправленный канал данных, который можно использовать 
    для взаимодействия между процессами. Массив pipefd используется для возврата двух 
    файловых описателей, указывающих на концы канала.  
    
    pipefd[0] указывает на конец канала для чтения.  
    pipefd[1] указывает на конец канала для записи.  
    Данные, записанные в конец канала, буферизируются ядром до тех пор, пока не будут прочитаны из конца канала для чтения.  
    
    Аргументы функции write():  
    + Файловый дескриптор    
    + Указатель на буфер с данными.  
    + Количество байтов.  
