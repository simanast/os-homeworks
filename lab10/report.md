## Лабораторная работа № 10

1.  Предположим, что процесс открывает файл на чтение по единственной жесткой ссылке (hard link) на существующий файл. В процессе этого чтения другой процесс удаляет эту ссылку. Что случится с операцией чтения первым процессом? Она завершится успешно? Написать программу и протестировать (также объяснить результат на основе документации). 

    Программа завершится успешно, т.к. мы удалили файл в помощью функции unlink().
    
        unlink () удаляет имя из файловой системы. 
        Если это имя было последней ссылкой на файл, 
        и файл не был открыт ни у одного процесса, файл удаляется, 
        а используемое им пространство становится доступным для повторного использования. 
        Если имя было последней ссылкой на файл, но файл был открыт во всех процессах, 
        файл будет существовать до тех пор, пока последний дескриптор файла, ссылающийся на него, 
        не будет закрыт.
    
    Т.е. содержимое файла будет выведено.
    
2.  Каково время выполнения программы, содержащей  2,000,000 инструкций на процессоре  8 MHz, когда каждая инструкция занимает 4 цикла.

    Всего операций:  
    2,000,000 * 4 = 8,000,000  
    8 MHz = 8 * 1,000,000 = 8,000,000 Hz  
    1 Гц = 1 сек^(−1)
    Значит, чтобы узнать нелбходимое время достаточно просто разделить количество операций на частоту:  
    8,000,000 операций/8,000,000 Hz = 1 секунда.  

    1 секунда - время выполнения программы, содержащей 2,000,000 инструкций на процессоре 8 MHz, когда каждая инструкция занимает 4 цикла.

3.  Рассмотреть систему, в которой виртуальный адрес 20 бит, а страница  1 KB. Сколько элементов в таблице страниц?
    
    Как и в случае простой страничной организации, страничная виртуальная память и физическая память представляются состоящими из наборов блоков или страниц одинакового размера. Виртуальные адреса делятся на страницы (page), соответствующие единицы в физической памяти образуют страничные кадры (page frames) виртуальный адрес состоит из виртуального номера страницы и смещения. Номер записи в таблице страниц соответствует номеру виртуальной страницы. Размер записи колеблется от системы к системе, но чаще всего он составляет 32 бита. Подсчитаем примерный размер таблицы страниц. В 20-битном адресном пространстве при размере страницы 1 Кбайт получаем
    
    2^20/2^10=2^10.
    
    Итого предположительное количество элементов в таблице страниц будет 1024.

4.  Рассмотреть алгоритмы диспетчеризации процессов (scheduling algorithms) по следующим критериям (метрикам)
(a) время ожидания (waiting time), 
(b) повышение приоритета "забытой" задачи (starvation), 
(c) время завершения (turnaround time), 
(d) вариативность времени завершения  (variance in turnaround time).
Какой из них приведет к высокой вариативности времени завершения?  

Одним из наиболее ограниченных ресурсов вычислительной системы является процессорное время. Для его распределения между многочисленными процессами в системе приходится применять процедуру планирования процессов.

Вытесняющее планирование.

В этом режиме планирования процесс может быть приостановлен в любой момент исполнения. Операционная система устанавливает специальный таймер для генерации сигнала прерывания по истечении некоторого интервала времени – кванта. После прерывания процессор передается в распоряжение следующего процесса. Временные прерывания помогают гарантировать приемлемое время отклика процессов для пользователей, работающих в диалоговом режиме, и предотвращают "зависание" компьютерной системы из-за зацикливания какой-либо программы.

Невытесняющее планирование.

При таком режиме планирования процесс занимает столько процессорного времени, сколько ему необходимо. При этом переключение процессов возникает только при желании самого исполняющегося процесса передать управление. Этот метод планирования относительно просто реализуем и достаточно эффективен, так как позволяет выделить большую часть процессорного времени для работы самих процессов и до минимума сократить затраты на переключение контекста. Однако при невытесняющем планировании возникает проблема возможности полного захвата процессора одним процессом, который вследствие каких-либо причин (например, из-за ошибки в программе) зацикливается и не может передать управление другому процессу. В такой ситуации спасает только перезагрузка всей вычислительной системы.

Простейшим алгоритмом планирования является алгоритм, который принято обозначать аббревиатурой FCFS по первым буквам его английского названия – First-Come, First-Served (первым пришел, первым обслужен). Такой алгоритм выбора процесса осуществляет невытесняющее планирование.

Среднее время ожидания и среднее полное время выполнения для этого алгоритма существенно зависят от порядка расположения процессов в очереди. Поэтому алгоритм FCFS практически неприменим для систем разделения времени – слишком большим получается среднее время отклика в интерактивных процессах.

    (a) время ожидания (waiting time) - зависят от порядка расположения процессов
    (b) повышение приоритета "забытой" задачи (starvation) - процесс занимает столько процессорного времени, сколько ему необходимо
    (c) время завершения (turnaround time) - зависят от порядка расположения процессов
    (d) вариативность времени завершения (variance in turnaround time) - процесс занимает столько процессорного времени, сколько ему необходимо

Модификацией алгоритма FCFS является алгоритм, получивший название Round Robin. Это тот же самый алгоритм, только реализованный в режиме вытесняющего планирования. Каждый процесс находится около процессора небольшой фиксированный квант времени.

среднее время ожидания и среднее полное время выполнения для обратного порядка процессов не отличаются от соответствующих времен для алгоритма FCFS На производительность алгоритма RR сильно влияет величина кванта времени.

При очень больших величинах кванта времени, алгоритм RR вырождается в алгоритм FCFS. При очень малых величинах создается иллюзия того, что каждый из n процессов работает на собственном виртуальном процессоре с производительностью ~ 1/n от производительности реального процессора. Правда, это справедливо лишь при теоретическом анализе при условии пренебрежения временами переключения контекста процессов.

В реальных условиях при слишком малой величине кванта времени и, соответственно, слишком частом переключении контекста накладные расходы на переключение резко снижают производительность системы.

    (a) время ожидания (waiting time) - каждый процесс находится около процессора небольшой фиксированный квант времени
    (b) повышение приоритета "забытой" задачи (starvation) - тут он аналогичен FCFS
    (c) время завершения (turnaround time) - при слишком малой величине кванта времени и, соответственно, слишком частом переключении контекста накладные расходы на переключение резко снижают производительность системы, а при большом он вырождается в FCFS
    (d) вариативность времени завершения (variance in turnaround time) - зависит от кванта.

Алгоритм способный выбрать для исполнения не процесс из начала очереди, а процесс с минимальной длительностью и если же таких процессов два или больше, то для выбора одного из них можно использовать уже известный нам алгоритм FCFS, без квантования времени при этом - этот алгоритм получил название "кратчайшая работа первой" или Shortest Job First ( SJF ).

SJF-алгоритм краткосрочного планирования может быть как вытесняющим, так и невытесняющим.

При невытесняющем SJF - планировании процессор предоставляется избранному процессу на все необходимое ему время, независимо от событий, происходящих в вычислительной системе.

При вытесняющем SJF - планировании учитывается появление новых процессов в очереди готовых к исполнению (из числа вновь родившихся или разблокированных) во время работы выбранного процесса. Если время выполнения нового процесса меньше, чем остаток у исполняющегося, то исполняющийся процесс вытесняется новым.

Основную сложность при реализации алгоритма SJF представляет невозможность точного знания продолжительности очередного времени выполнения для исполняющихся процессов. В пакетных системах количество процессорного времени, необходимое заданию для выполнения, указывает пользователь при формировании задания. алгоритм SJF является оптимальным с точки зрения минимизации среднего времени ожидания среди класса невытесняющих алгоритмов.

    (a) время ожидания (waiting time) - если алгоритм вытесняющий: то процесс с наименьшим временем выполнения вытесняет другой. Иначе, процесс получает все время, что ему необходимо.
    (b) повышение приоритета "забытой" задачи (starvation) - если процесс занимает много времени, то он может долго ожидать выполнения
    (c) время завершения (turnaround time) - бытрые процессы выполняются быстро, когда как длительные ожидают своего выполненния
    (d) вариативность времени завершения (variance in turnaround time) - присутсвует.

Разработан и другой класс алгоритмов планирования. Для каждой группы процессов создается своя очередь процессов, находящихся в состоянии готовность. Этим очередям приписываются фиксированные приоритеты. Внутри этих очередей для планирования могут применяться самые разные алгоритмы. Так, например, для больших счетных процессов, не требующих взаимодействия с пользователем (фоновых процессов), может использоваться алгоритм FCFS, а для интерактивных процессов – алгоритм RR. Подобный подход, получивший название многоуровневых очередей, повышает гибкость планирования: для процессов с различными характеристиками применяется наиболее подходящий им алгоритм.

Подобный подход, получивший название многоуровневых очередей, повышает гибкость планирования: для процессов с различными характеристиками применяется наиболее подходящий им алгоритм.

Простейшим алгоритмом планирования является невытесняющий алгоритм FCFS, который, однако, может существенно задерживать короткие процессы, не вовремя перешедшие в состояние готовность. В системах разделения времени широкое распространение получила вытесняющая версия этого алгоритма – RR.

Среди всех невытесняющих алгоритмов оптимальным с точки зрения среднего времени ожидания процессов является алгоритм SJF. Существует и вытесняющий вариант этого алгоритма.

Алгоритм SJF является частным случаем планирования с использованием приоритетов. В более общих методах приоритетного планирования применяются многоуровневые очереди процессов, готовых к исполнению. Будучи наиболее сложным в реализации, этот способы планирования обеспечивает гибкое поведение вычислительных систем и их адаптивность к решению задач разных классов.

    Приведет к высокой вариативности времени завершения скорее всего FCFS, так как он просто выполняет процессы в порядке очереди. Следующим за ним будет FJS, так время завершения будет просто увеличиваться, казалось бы. И последний RR, зависящий от кванта времени на процесс.

